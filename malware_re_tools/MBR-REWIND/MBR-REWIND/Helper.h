#pragma once
#include "stdafx.h"

const int WARN_FOREGROUND = 14;
const int BANNER_FOREGROUND = 8;
const int HEX_FOREGROUND = 14;
const int RESTORE_FOREGROUND = 10;
const int WRITE_FOREGROUND = 12;
const int TEXT_FOREGROUND = 11;
const int BOOT_SECTOR_SIZE = 512;
const int SUCCESS_FOREGROUND = 11;
const int ERROR_FOREGROUND = 12;
const int SIMULATE_FOREGROUND = 6;

LPCTSTR lpszPhysicalDR0 = L"\\\\.\\PhysicalDrive0";
LPCTSTR lpszMBRCurrentStateFileName = L"_CURRENT-MBR-CODE.bin";
LPCTSTR lpszMBRBackupStateFileName = L"MBR-BACKUP-CODE.bin";
LPCTSTR lpszMalMBRFileName = L"MAL-MBR.bin";

//*********************************************************************

void ShowError(LPCSTR, HANDLE, WORD);
void SuccessMsg(LPTSTR, HANDLE, WORD);
void MemHexDump(LPVOID, DWORD, HANDLE, WORD, int);
void ComputeHash(LPVOID, DWORD, wchar_t*, HANDLE, WORD);
void CloseHandleAndExit(HANDLE);
//*********************************************************************


void ShowError(LPCSTR lpszFunction, HANDLE hConsole, WORD wOriginalAttributes)
{
    // Retrieve the system error message for the last-error code

    LPWSTR lpMsgBuf;
    DWORD dw = GetLastError();

    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dw,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR)&lpMsgBuf,
        0, NULL);

    // Display the error message and exit the process
    if (dw > 0)
    {
        SetConsoleTextAttribute(hConsole, ERROR_FOREGROUND);
        printf("[-] STATUS: [FAILED]--[%s:%s]--[FUNC: %s]--[LINE_NUMBER: %d]--> with error %d: %ws \n", __DATE__, __TIME__, lpszFunction, __LINE__, dw, lpMsgBuf);
        LocalFree(lpMsgBuf);
        SetConsoleTextAttribute(hConsole, wOriginalAttributes);
    }
}

bool CheckIfFileExist(wchar_t* lpstrBackUpFilePath, HANDLE hConsole, int wOriginalAttributes)
{
    BOOL result = 0;
    result = PathFileExistsW(lpstrBackUpFilePath);
    if (!result)
    {
        SetConsoleTextAttribute(hConsole, WARN_FOREGROUND);
        printf("\n[+] WARNING: Please create first a restore-backup MBR code 'MBR-REWIND.exe -b' before playing around ;)\n\n");
        SetConsoleTextAttribute(hConsole, wOriginalAttributes);
        ShowError(__FUNCTION__, hConsole, wOriginalAttributes);
        ExitProcess(1);
    }
    return result;
}

void MemHexDump(LPVOID MemData, DWORD DataSize, HANDLE hConsole, WORD wOriginalAttributes, int iForeground)
{
    SetConsoleTextAttribute(hConsole, iForeground);
    DWORD ofs = 0x00;
    printf("\n\n+------------[DUMPHEX]------------+\n\n");

    printf("OFFSET     : 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f | \n");
    printf("-----------: ----------------------------------------------- | \n");
    printf("0x%08x : ", ofs);
    char asciiValue[17] = "\0";
    int i, j;
    for (i = 0; i <= DataSize; i++)
    {
        if (i > 0 && (i % 0x10 == 0))
        {
            printf("| ");
            for (j = 0; j <= 0x10; j++)
            {
                printf("%c", asciiValue[j]);
            }
            printf("\n");
            printf("0x%08x : ", i);
        }
        printf("%02X ", ((unsigned char*)MemData)[i]);
        if (((unsigned char*)MemData)[i] >= ' ' && ((unsigned char*)MemData)[i] <= '~')
        {
            asciiValue[i % 16] = ((unsigned char*)MemData)[i];
        }
        else
        {
            asciiValue[i % 16] = '.';
        }
    }
    printf("\n\n+------------[DUMPHEX]------------+\n\n");

    SetConsoleTextAttribute(hConsole, wOriginalAttributes);
}

void SuccessMsg(LPTSTR Msg, HANDLE hConsole, WORD wOriginalAttributes)
{
    SetConsoleTextAttribute(hConsole, SUCCESS_FOREGROUND);
    printf("[+] STATUS: [SUCCESS] --> %ws", Msg);
    SetConsoleTextAttribute(hConsole, wOriginalAttributes);
}

void CloseHandleAndExit(HANDLE fh)
{
    CloseHandle(fh);
    ExitProcess(1);
}

void ComputeHash(LPVOID buffer, DWORD CodeSize, wchar_t* Sha1Value, HANDLE hConsole, WORD wOriginalAttributes)
{
    const int SHA1LEN = 20;
    const int BUFFSIZE = 1024;

    HCRYPTPROV hProv = 0;
    HCRYPTHASH hHash = 0;
    DWORD cbHash = 0;
    DWORD dwStatus = 0;


    // Get handle to the crypto provider
    if (!CryptAcquireContext(&hProv,
        NULL,
        NULL,
        PROV_RSA_FULL,
        CRYPT_VERIFYCONTEXT))
    {
        ShowError(__FUNCTION__, hConsole, wOriginalAttributes);
    }

    if (!CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash))
    {
        CryptReleaseContext(hProv, 0);
        ShowError(__FUNCTION__, hConsole, wOriginalAttributes);
    }

    if (!CryptHashData(hHash, (BYTE*)buffer, CodeSize, 0))
    {
        CryptReleaseContext(hProv, 0);
        CryptDestroyHash(hHash);
        ShowError(__FUNCTION__, hConsole, wOriginalAttributes);
    }
    cbHash = SHA1LEN;
    BYTE rgbHash[SHA1LEN];
    CHAR rgbDigits[] = "0123456789abcdef";
    if (CryptGetHashParam(hHash, HP_HASHVAL, rgbHash, &cbHash, 0))
    {
        int ptr = 0;
        SuccessMsg(TEXT("SHA1 hash of read code:  "), hConsole, wOriginalAttributes);
        for (DWORD i = 0; i < cbHash; i++)
        {
            printf("%c%c", rgbDigits[rgbHash[i] >> 4], rgbDigits[rgbHash[i] & 0xf]);
            Sha1Value[i + ptr] = rgbDigits[rgbHash[i] >> 4];
            Sha1Value[i + 1 + ptr] = rgbDigits[rgbHash[i] & 0xf];
            ptr++;

        }
        printf("\n");
        Sha1Value[40] = 0;
        //printf("%ws",Sha1Value);
    }
    else
    {
        dwStatus = GetLastError();
        ShowError(__FUNCTION__, hConsole, wOriginalAttributes);
    }
    CryptDestroyHash(hHash);
    CryptReleaseContext(hProv, 0);
}

LPVOID ReadIO(LPCTSTR FileName, DWORD dwNumOfBytesToRead, HANDLE hConsole, WORD wOriginalAttributes)
{

    HANDLE fh = 0;
    DWORD dwNumOfBytesRead = 0;
    LPVOID lpBuffer;
    size_t MemBlockSize = 1024;
    wchar_t wcHashValue[41] = { 0 };

    fh = CreateFile(FileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
    if (fh == INVALID_HANDLE_VALUE)
    {
        ShowError(__FUNCTION__, hConsole, wOriginalAttributes);
        CloseHandleAndExit(fh);
    }
    SuccessMsg(TEXT("in opening read handle of PhysicalDrive0\n"), hConsole, wOriginalAttributes);

    lpBuffer = malloc(MemBlockSize);
    if (NULL == lpBuffer)
    {
        ShowError(__FUNCTION__, hConsole, wOriginalAttributes);
        CloseHandleAndExit(fh);


    }
    if (!ReadFile(fh, lpBuffer, dwNumOfBytesToRead, &dwNumOfBytesRead, NULL))
    {
        ShowError(__FUNCTION__, hConsole, wOriginalAttributes);
        free(lpBuffer);
        CloseHandleAndExit(fh);
        
    }
    CloseHandle(fh);
    SuccessMsg(TEXT("in reading MBR code in PhysicalDrive0\n"), hConsole, wOriginalAttributes);

    return lpBuffer;
}

void WriteToAFile(LPVOID lpBuffer, int CodeSize, LPTSTR wcHashValue, HANDLE hConsole, WORD wOriginalAttributes, LPCTSTR DumpBinFileName, BOOL bHashFlag)
{

    wchar_t cMBRFileName[128] = { 0 };
    if (bHashFlag)
    {
        wcscpy_s(cMBRFileName, _countof(cMBRFileName), wcHashValue);
    }

    wcscat_s(cMBRFileName, _countof(cMBRFileName), DumpBinFileName);

    HANDLE ffh = 0;
    ffh = CreateFile((wchar_t*)cMBRFileName, GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, CREATE_ALWAYS, 0, 0);
    if (ffh == INVALID_HANDLE_VALUE)
    {
        ShowError(__FUNCTION__, hConsole, wOriginalAttributes);

    }
    SuccessMsg(TEXT("in opening a handle for dumping MBR code.\n"), hConsole, wOriginalAttributes);


    if (!WriteFile(ffh, lpBuffer, CodeSize, NULL, 0))
    {

        ShowError(__FUNCTION__, hConsole, wOriginalAttributes);
        CloseHandleAndExit(ffh);
    }

    CloseHandle(ffh);
    SuccessMsg(TEXT("in saving the current MBR code to a file: \n"), hConsole, wOriginalAttributes);
    printf("[+] STATUS: [SUCCESS] --> filename: %ws\n", cMBRFileName);

}

void OverWriteStream(DWORD CodeSize, HANDLE hConsole, WORD wOriginalAttributes, LPVOID lpMalBuffer, LPCTSTR BootFileName)
{
    HANDLE fh = 0;
    if ((fh = CreateFile(BootFileName, GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0)) == INVALID_HANDLE_VALUE)
    {
        ShowError(__FUNCTION__, hConsole, wOriginalAttributes);
        CloseHandleAndExit(fh);
    }

    SuccessMsg(TEXT("in opening a handle of PhysicalDrive0 for writing\n"), hConsole, wOriginalAttributes);
    if (!WriteFile(fh, lpMalBuffer, CodeSize, NULL, 0))
    {
        ShowError(__FUNCTION__, hConsole, wOriginalAttributes);
    }
    SuccessMsg(TEXT("in overwriting MBR sector.\n"), hConsole, wOriginalAttributes);

    CloseHandle(fh);

}