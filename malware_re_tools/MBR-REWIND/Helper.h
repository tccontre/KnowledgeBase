#pragma once
#include "stdafx.h"

const int WARN_FOREGROUND = 14;
const int BANNER_FOREGROUND = 8;
const int HEX_FOREGROUND = 14;
const int RESTORE_FOREGROUND = 10;
const int WRITE_FOREGROUND = 12;
const int TEXT_FOREGROUND = 11;
const int BOOT_SECTOR_SIZE = 512;
const int SUCCESS_FOREGROUND = 11;
const int ERROR_FOREGROUND = 12;

//*********************************************************************

void ErrorExit(LPTSTR, HANDLE, WORD);
void Banner(HANDLE, WORD, int);
void WarningMessage(HANDLE, WORD, int);
void Help(HANDLE, WORD, int);
void SuccessMsg(LPTSTR , HANDLE , WORD );
void MemHexDump(LPVOID , DWORD , HANDLE , WORD, int );
void ComputeHash(LPVOID, DWORD, wchar_t*, HANDLE, WORD);
void SaveMBRCodeToAFile(LPVOID, int, wchar_t*, HANDLE, WORD, wchar_t*, bool);
void ReadDisplaySaveMBRCode(DWORD , HANDLE , WORD , wchar_t*, bool, int);
void OverwriteMBRSector(wchar_t*, DWORD, HANDLE, WORD);
LPVOID ReadMBRCodeFromFile(wchar_t*, DWORD, HANDLE, WORD);
//*********************************************************************


void ErrorExit(LPTSTR lpszFunction, HANDLE hConsole, WORD wOriginalAttributes)
{
    // Retrieve the system error message for the last-error code

    LPWSTR lpMsgBuf;
    DWORD dw = GetLastError();

    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dw,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR)&lpMsgBuf,
        0, NULL);

    // Display the error message and exit the process
    if (dw > 0)
    {
        SetConsoleTextAttribute(hConsole, ERROR_FOREGROUND);
        printf("[-] STATUS: [FAILED] --> %ws, with error %d: %ws \n", lpszFunction, dw, lpMsgBuf);
        LocalFree(lpMsgBuf);
        SetConsoleTextAttribute(hConsole, wOriginalAttributes);
    }
    ExitProcess(dw);

}

void SuccessMsg(LPTSTR Msg, HANDLE hConsole, WORD wOriginalAttributes)
{
    SetConsoleTextAttribute(hConsole, SUCCESS_FOREGROUND);
    printf("[+] STATUS: [SUCCESS] --> %ws", Msg);
    SetConsoleTextAttribute(hConsole, wOriginalAttributes);
}


void MemHexDump(LPVOID MemData, DWORD DataSize, HANDLE hConsole, WORD wOriginalAttributes, int iForeground)
{
    SetConsoleTextAttribute(hConsole, iForeground);
    DWORD ofs = 0x00;
    printf("\n\n+------------[DUMPHEX]------------+\n\n");

    printf("OFFSET     : 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f | \n");
    printf("-----------: ----------------------------------------------- | \n");
    printf("0x%08x : ", ofs);
    char asciiValue[17] = "\0";
    int i, j;
    for (i = 0; i <= DataSize; i++)
    {
        if (i > 0 && (i % 0x10 == 0))
        {
            printf("| ");
            for (j = 0; j <= 0x10; j++)
            {
                printf("%c", asciiValue[j]);
            }
            printf("\n");
            printf("0x%08x : ", i);
        }
        printf("%02X ", ((unsigned char*)MemData)[i]);
        if (((unsigned char*)MemData)[i] >= ' ' && ((unsigned char*)MemData)[i] <= '~')
        {
            asciiValue[i % 16] = ((unsigned char*)MemData)[i];
        }
        else
        {
            asciiValue[i % 16] = '.';
        }
    }
    printf("\n\n+------------[DUMPHEX]------------+\n\n");

    SetConsoleTextAttribute(hConsole, wOriginalAttributes);
}


void ReadDisplaySaveMBRCode(DWORD BOOT_SECTOR_SIZE, HANDLE hConsole, WORD wOriginalAttributes, wchar_t* cMBRCodeFileName, bool bHashFlag, int iForeground)
{

    HANDLE fh= 0;
    fh = CreateFile(L"\\\\.\\PhysicalDrive0", GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
    if (fh == INVALID_HANDLE_VALUE)
    {
        ErrorExit(TEXT("(ReadDisplaySaveMBRCode) - CreateFile - PhysicalDrive0 "), hConsole, wOriginalAttributes);
        CloseHandle(fh);
        exit(1);
    }
    SuccessMsg(TEXT("in opening read handle of PhysicalDrive0\n"), hConsole, wOriginalAttributes);
   
    DWORD dwNumOfBytesToRead = BOOT_SECTOR_SIZE;
    DWORD dwNumOfBytesRead = 0;
    LPVOID lpBuffer;
    size_t MemBlockSize = 1024;
    wchar_t wcHashValue[41] = { 0 };
    lpBuffer = malloc(MemBlockSize);
    if (NULL == lpBuffer)
    {
        CloseHandle(fh);
        ErrorExit(TEXT("(ReadDisplaySaveMBRCode) - malloc "), hConsole, wOriginalAttributes);
        
        
    }
    if (!ReadFile(fh, lpBuffer, dwNumOfBytesToRead, &dwNumOfBytesRead, NULL))
    {
        CloseHandle(fh);
        ErrorExit(TEXT("(ReadDisplaySaveMBRCode) - ReadFile - PhysicalDrive0 "), hConsole, wOriginalAttributes);

    }
    CloseHandle(fh);

    SuccessMsg(TEXT("in reading MBR code in PhysicalDrive0\n"), hConsole, wOriginalAttributes);

    ComputeHash(lpBuffer, BOOT_SECTOR_SIZE, wcHashValue, hConsole, wOriginalAttributes);
    
    MemHexDump(lpBuffer, BOOT_SECTOR_SIZE, hConsole, wOriginalAttributes, iForeground);

    SaveMBRCodeToAFile(lpBuffer, BOOT_SECTOR_SIZE, wcHashValue, hConsole, wOriginalAttributes, cMBRCodeFileName, bHashFlag);

    free(lpBuffer);

}


void ComputeHash(LPVOID buffer, DWORD CodeSize, wchar_t* Sha1Value,  HANDLE hConsole, WORD wOriginalAttributes)
{
#define SHA1LEN 20
#define BUFFSIZE 1024

    HCRYPTPROV hProv = 0;
    HCRYPTHASH hHash = 0;
    DWORD cbHash = 0;
    DWORD dwStatus = 0;

    // Get handle to the crypto provider
    if (!CryptAcquireContext(&hProv,
        NULL,
        NULL,
        PROV_RSA_FULL,
        CRYPT_VERIFYCONTEXT))
    {
        ErrorExit(TEXT("(ComputeHash) - CryptAcquireContext "), hConsole, wOriginalAttributes);
    }

    if (!CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash))
    {
        CryptReleaseContext(hProv, 0);
        ErrorExit(TEXT("(ComputeHash) - CryptCreateHash "), hConsole, wOriginalAttributes);
    }

    if (!CryptHashData(hHash, (BYTE *) buffer, CodeSize, 0))
    {
        CryptReleaseContext(hProv, 0);
        CryptDestroyHash(hHash);
        ErrorExit(TEXT("(ComputeHash) - CryptHashData "), hConsole, wOriginalAttributes);
    }
    cbHash = SHA1LEN;
    BYTE rgbHash[SHA1LEN];
    CHAR rgbDigits[] = "0123456789abcdef";
    if (CryptGetHashParam(hHash, HP_HASHVAL, rgbHash, &cbHash, 0))
    {
        int ptr = 0;
        SuccessMsg(TEXT("in computing the hash of MBR code. SHA1 hash is:  "), hConsole, wOriginalAttributes);
        for (DWORD i = 0; i < cbHash; i++)
        {
            printf("%c%c", rgbDigits[rgbHash[i] >> 4], rgbDigits[rgbHash[i] & 0xf]);
            Sha1Value[i + ptr] = rgbDigits[rgbHash[i] >> 4];
            Sha1Value[i + 1 + ptr] = rgbDigits[rgbHash[i] & 0xf];
            ptr++;
            
        }
        printf("\n");
        Sha1Value[40] = 0;
    }
    else
    {
        dwStatus = GetLastError();
        ErrorExit(TEXT("(ComputeHash) - CryptGetHashParam "), hConsole, wOriginalAttributes);
    }
    CryptDestroyHash(hHash);
    CryptReleaseContext(hProv, 0);
}


void SaveMBRCodeToAFile(LPVOID Buffer, int CodeSize,  wchar_t* wcHashValue,  HANDLE hConsole, WORD wOriginalAttributes, wchar_t* cMBRCodeFileName, bool bHashFlag)
{
    
    wchar_t cMBRFileName[128] = { 0 };
    if (bHashFlag)
    {
        wcscpy_s(cMBRFileName, _countof(cMBRFileName), wcHashValue);
    }
   
    wcscat_s(cMBRFileName, _countof(cMBRFileName), cMBRCodeFileName);

    HANDLE ffh = 0;
    ffh = CreateFile((wchar_t*)cMBRFileName, GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, CREATE_ALWAYS, 0, 0);
    if (ffh == INVALID_HANDLE_VALUE)
    {        
        ErrorExit(TEXT("(SaveMBRCodeToAFile) - CreateFile "), hConsole, wOriginalAttributes);

    }
    SuccessMsg(TEXT("in opening a handle for dumping MBR code.\n"), hConsole, wOriginalAttributes);
    

    if (!WriteFile(ffh, Buffer, CodeSize, NULL, 0))
    {

        ErrorExit(TEXT("(SaveMBRCodeToAFile) - WriteFile \n"), hConsole, wOriginalAttributes);
        CloseHandle(ffh);
    }

    CloseHandle(ffh);
    SuccessMsg(TEXT("in saving the current MBR code to a file: \n"), hConsole, wOriginalAttributes);
    printf("[+] STATUS: [SUCCESS] --> filename: %ws\n",cMBRFileName);

}


void OverwriteMBRSector(wchar_t* cMBRCodeFileName, DWORD CodeSize, HANDLE hConsole, WORD wOriginalAttributes)
{
    HANDLE fh;
    //read malicious MBR
    LPVOID ptrlpMalBuffer = ReadMBRCodeFromFile(cMBRCodeFileName, CodeSize, hConsole, wOriginalAttributes);

    if ((fh = CreateFile(L"\\\\.\\PhysicalDrive0", GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0)) == INVALID_HANDLE_VALUE)
    {
        ErrorExit(TEXT("(OverwriteMBRSector) - CreateFile - PhysicalDrive0 "), hConsole, wOriginalAttributes);
        CloseHandle(fh);
    }

    SuccessMsg(TEXT("in opening a handle of PhysicalDrive0 for writing\n"), hConsole, wOriginalAttributes);
    if (!WriteFile(fh, ptrlpMalBuffer, CodeSize, NULL, 0))
    {
        ErrorExit(TEXT("(OverwriteMBRSector) - WriteFile - PhysicalDrive0 "), hConsole, wOriginalAttributes);
    }
    SuccessMsg(TEXT("in overwriting MBR sector.\n"), hConsole, wOriginalAttributes);
    
    CloseHandle(fh);
}


LPVOID ReadMBRCodeFromFile(wchar_t* cMBRCodeFileName, DWORD CodeSize, HANDLE hConsole, WORD wOriginalAttributes)
{
    LPVOID lpBuffer;
    DWORD dwNumOfBytesToRead = CodeSize;
    DWORD dwNumberOfBytesRead = 0;
    HANDLE fh;
    size_t memBlock = 1024;

    if ((fh = CreateFile(cMBRCodeFileName, GENERIC_ALL, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0)) == INVALID_HANDLE_VALUE)
    {
        ErrorExit(TEXT("(ReadMBRCodeFromFile) - CreateFile - mal_mbr.bin"), hConsole, wOriginalAttributes);

    }
    
    SuccessMsg(TEXT("in opening a file handle of mal_mbr.bin\n"), hConsole, wOriginalAttributes);

    lpBuffer = malloc(memBlock);
    if (lpBuffer == NULL)
    {
        CloseHandle(fh);
        ErrorExit(TEXT("(ReadMBRCodeFromFile) - malloc - mal_mbr.bin"), hConsole, wOriginalAttributes);
    }


    if (!ReadFile(fh, lpBuffer, dwNumOfBytesToRead, &dwNumberOfBytesRead, NULL))
    {
        CloseHandle(fh);
        ErrorExit(TEXT("(ReadMBRCodeFromFile) - ReadFile - mal_mbr.bin"), hConsole, wOriginalAttributes);
        exit(1);

    }

    SuccessMsg(TEXT("in reading MBR code from mal_mbr.bin file.\n"), hConsole, wOriginalAttributes);
    CloseHandle(fh);

    return lpBuffer;
}

bool CheckIfFileExist(wchar_t * lpstrBackUpFilePath, HANDLE hConsole, int wOriginalAttributes)
{
    BOOL result = 0;
    result = PathFileExistsW(lpstrBackUpFilePath);
    if (!result)
    {
        SetConsoleTextAttribute(hConsole, WARN_FOREGROUND);
        printf("\n[+] WARNING: Please create first a restore-backup mbr code 'MBR-REWIND.exe -b' before playing around ;)\n\n");
        SetConsoleTextAttribute(hConsole, wOriginalAttributes);

        ErrorExit(TEXT("(Backup function) - PathFileExistsW"), hConsole, wOriginalAttributes);

    }
    return true;
}
