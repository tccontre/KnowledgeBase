__author__ = "tcontre - Br3akp0int"

"""
description: a simple idapython script to decrypt the IcedID corebot strings and create a comment for decrypted value for better static analysis 
"""

import os
import sys
import re
import idaapi
import idautils
import idc
import binascii
import ida_loader
import ida_bytes

##################################################

#define o_void        0  // No Operand                           ----------
#define o_reg         1  // General Register (al, ax, es, ds...) reg
#define o_mem         2  // Direct Memory Reference  (DATA)      addr
#define o_phrase      3  // Memory Ref [Base Reg + Index Reg]    phrase
#define o_displ       4  // Memory Reg [Base Reg + Index Reg + Displacement] phrase+addr
#define o_imm         5  // Immediate Value                      value
#define o_far         6  // Immediate Far Address  (CODE)        addr
#define o_near        7  // Immediate Near Address (CODE)        addr
#define o_idpspec0    8  // IDP specific type
#define o_idpspec1    9  // IDP specific type
#define o_idpspec2   10  // IDP specific type
#define o_idpspec3   11  // IDP specific type
#define o_idpspec4   12  // IDP specific type
#define o_idpspec5   13  // IDP specific type

##// x86
#define o_trreg         o_idpspec0      // trace register
#define o_dbreg         o_idpspec1      // debug register
#define o_crreg         o_idpspec2      // control register
#define o_fpreg         o_idpspec3      // floating point register
#define o_mmxreg        o_idpspec4      // mmx register
#define o_xmmreg        o_idpspec5      // xmm register

##// arm
#define o_reglist       o_idpspec1      // Register list (for LDM/STM)
#define o_creglist      o_idpspec2      // Coprocessor register list (for CDP)
#define o_creg          o_idpspec3      // Coprocessor register (for LDC/STC)
#define o_fpreglist     o_idpspec4      // Floating point register list
#define o_text          o_idpspec5      // Arbitrary text stored in the operand
#define o_cond          (o_idpspec5+1)  // ARM condition as an operand

##// ppc
#define o_spr           o_idpspec0      // Special purpose register
#define o_twofpr        o_idpspec1      // Two FPRs
#define o_shmbme        o_idpspec2      // SH & MB & ME
#define o_crf           o_idpspec3      // crfield      x.reg
#define o_crb           o_idpspec4      // crbit        x.reg
#define o_dcr           o_idpspec5      // Device control register

##################################################


class IcedIDDecryptor:

    def __init__(self):

        self.list_of_dec_func_name = ["func_decryptIcedIDStr"]
        self.list_of_reg_func_addr = []
        self.list_of_dec_func_addr = []
        self.list_of_addr_xref_dec_func = []
        self.MAX_SEARCH = 13
        return

    def enum_regular_func(self, ea):

        for func_addr in Functions(get_segm_start(ea), get_segm_end(ea)):
            func_flag = get_func_attr(func_addr, FUNCATTR_FLAGS)

            if not self.is_normal_func(func_addr):
                continue
            else:
                self.list_of_reg_func_addr.append(func_addr)

        return 

    def is_normal_func(self, func_flag):
        if func_flag & FUNC_LIB or func_flag & FUNC_THUNK:
            return True
        else:
            return False

    def check_func_name_if_decryption(self):
        
        for func_addr in self.list_of_reg_func_addr:
            func_name = get_func_name(func_addr)
            
            if func_name in self.list_of_dec_func_name:
                print ("[+] SUCCESS: Found {} function with address of {}".format(func_name, hex(func_addr)))
                self.list_of_dec_func_addr.append(func_addr)
            else:
                pass

        return

    def find_xref(self):
        
        for func_addr in self.list_of_dec_func_addr:
            for addr in XrefsTo(func_addr, flags=0):
                self.list_of_addr_xref_dec_func.append(addr.frm)
        return

    def ROL(self, data, shift, size=32):
        shift %= size
        remains = data >> (size - shift)
        body = (data << shift) - (remains << size )
        return (body + remains)
     
 
    def ROR(self, data, shift, size=32):
        shift %= size
        body = data >> shift
        remains = (data << (size - shift)) - (body << size)
        return (body + remains)

    def dec_rol(self, hash_key):
        hash_key_add = (hash_key + 0x2e59) & 0xFFFFFFFF
        eax = self.ROR(hash_key_add,4) & 0xFFFFFFFF
        eax = (eax ^ 0x151d) & 0xFFFFFFFF
        eax = self.ROL(eax,3) & 0xFFFFFFFF
        return eax

    def simulate_decryption(self, enc_str_addr, xref_addr):

        dword_bytes = get_wide_dword(enc_str_addr)
        word_bytes = get_wide_word(enc_str_addr + 4)
        init_hash_key = dword_bytes ^ word_bytes
        loop_len = init_hash_key & 0x0000FFFF
        init_dec_key_ptr = enc_str_addr + 6
        print("address_call_decrypt: {} 1st_dword: {} word_key: {} init_hash_key :{} loop_len: {} init_dec_key_ptr: {}".format(hex(xref_addr),
                                                                                                      hex(dword_bytes),
                                                                                                      hex(word_bytes),
                                                                                                      hex(init_hash_key), hex(loop_len), hex(init_dec_key_ptr)))
        dec_str = ""
        hash_key = dword_bytes
        for i in range (0, loop_len):

            hash_key = self.dec_rol(hash_key)
            dec_key_byte = get_wide_byte(init_dec_key_ptr + i)

            #print(hex(hash_key), hex(dec_key_byte))
            dec_byte = (hash_key & 0x000000FF) ^ dec_key_byte

            #print(hex(x))
            if dec_byte == 0x00:
                dec_byte = 0x20
            dec_str +=chr(dec_byte)

        print("[+] SUCCESS: decrypted string: -------\n {}".format(dec_str))

        set_cmt(xref_addr, dec_str, 0)
        return
    

    def process_lea_mnem(self, mnem, cur_inst_addr, xref_addr):
        lea_addr = cur_inst_addr

        ## look for the operand type of the lea
        op1_type = get_operand_type(lea_addr, 0)
        op2_type = get_operand_type(lea_addr, 1)

        ## find the first lea with the following operand type
        if op1_type == o_reg and op2_type == o_mem:

            op1 = idc.print_operand(lea_addr,0)
            op2 = idc.print_operand(lea_addr,1)
            
            #print(hex(cur_inst_addr), mnem, op1, op2)
            print("{0:08x} {1}".format(cur_inst_addr,idc.generate_disasm_line(cur_inst_addr, GENDSM_FORCE_CODE )))    

            # get operand2 values of lea which is the address of the encrypted string
            enc_str_addr = idc.get_operand_value(cur_inst_addr,1)

            print ("[+] SUCCESS: Found encrypted string address in {}".format(hex(enc_str_addr)))

            self.simulate_decryption(enc_str_addr, xref_addr)

            return True
        else:
            return False
        
        


    def process_mov_mnem(self, mnem, cur_inst_addr, xref_addr):
        mov_addr = cur_inst_addr

        ## look for the operand type of the mov
        op1_type = get_operand_type(mov_addr, 0)
        op2_type = get_operand_type(mov_addr, 1)
        
        if op1_type == o_reg and op2_type == o_mem:

            print("xxxxxxxxx")
                                
            op1 = idc.print_operand(mov_addr,0)
            op2 = idc.print_operand(mov_addr,1)

            print("{0:08x} {1}".format(cur_inst_addr,idc.generate_disasm_line(cur_inst_addr, GENDSM_FORCE_CODE )))

            ## operand2 of mov is ptr to the actual encrypted string address    
            ptr_of_enc_str_addr = get_operand_value(mov_addr, 1)

            enc_str_addr = get_qword(ptr_of_enc_str_addr)

            print ("[+] SUCCESS: Found encrypted string address in {}".format(hex(enc_str_addr)))

            self.simulate_decryption(enc_str_addr, xref_addr)

            return True
        else:
            return False
        
    def parse_mnem_inst(self):
        
        for cur_inst_addr in self.list_of_addr_xref_dec_func:
            xref_addr = cur_inst_addr
            
            for inst in range(0,self.MAX_SEARCH):
                cur_inst_addr = prev_head(cur_inst_addr)

                #grab the mnem command
                mnem = print_insn_mnem(cur_inst_addr)

                if mnem == "lea":
                    if self.process_lea_mnem(mnem, cur_inst_addr, xref_addr):
                        break
                elif mnem == "mov":
                    if self.process_mov_mnem(mnem, cur_inst_addr, xref_addr):
                        break

        return

    def run_decrypt(self):

        ea = get_screen_ea()

        ## iterate all the non compiler, lib, thunk functions
        self.enum_regular_func(ea)


        ## look for decryption function thru function name checking
        self.check_func_name_if_decryption()

        ## look which code reference the decryption routine.
        self.find_xref()

        print("[+] SUCCESS: Number of xref decryption routine: {}".format(len(self.list_of_addr_xref_dec_func)))
        print("[+] SUCCESS: list of xref addres: \n {}".format([hex(i) for i in self.list_of_addr_xref_dec_func]))

        ## locate the encrypted string address by parsing lea mnemonic before to the call to decryption routine
        self.parse_mnem_inst()

        return


def main():

    icd = IcedIDDecryptor()

    icd.run_decrypt()

    return



if __name__ == "__main__":
    main()











































