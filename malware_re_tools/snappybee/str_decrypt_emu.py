import hexdump
import os
import sys
import idc
import idaapi
import idautils
import ida_hexrays
from unicorn import *
from unicorn.x86_const import *
import struct
import capstone as cs

def get_function_arguments(func_addr):

    """
    locate ECX and EDX opcode
    ECX = param1
    EDX = param2

    seg000:004C2CDC BA 8C 76 4C 00                          mov     edx, 4C768Ch
    seg000:004C2CE1 B9 B0 7B 4C 00                          mov     ecx, 4C7BB0h
    seg000:004C2CE6 E8 2B DE FF FF                          call    mwDynamicApiResolver
    """

    ## lets readd mnemonics 10 lines up
    MAX_SEARCH = 10



    addrs_ptr = func_addr
    params = {}
    for i in range(0, MAX_SEARCH):
        addrs_ptr = idc.prev_head(addrs_ptr)
        mnem = idc.print_insn_mnem(addrs_ptr)
        if mnem == "mov":
            mnem_addr = addrs_ptr
            op_type1 = idc.get_operand_type(addrs_ptr, 0)
            op_type2 = idc.get_operand_type(addrs_ptr, 1)            
            reg_name = idc.print_operand(addrs_ptr, 0)
            
            
            if op_type1 == o_reg and op_type2 == o_imm and (reg_name == "edx" or reg_name == "ecx"):
                op1 = idc.get_operand_value(addrs_ptr,0)
                op2 = idc.get_operand_value(addrs_ptr,1)
                print(hex(func_addr), op1, hex(op2), reg_name)
                params[reg_name] = op2              

    return params

def enumerate_functions():
    func_dict = {}

    # iterate on the functions and exclude some func type
    for func_addr in idautils.Functions():

        func_flag = idc.get_func_flags(func_addr)

        # filter out some normal function
        if (func_flag & FUNC_LIB) or (func_flag & FUNC_THUNK):
            continue
        else:
            # check if function exist on the idb
            func_name = idc.get_func_name(func_addr)
            #print(f"{hex(func_addr)}: {func_name}")
            func_dict[func_name] = func_addr


    return func_dict

def is_func_name_exist(enum_func, func_name):

    if func_name in enum_func:
        return True
    else:
        return False

def enumerate_xref(func_addr):
    xref_addr_list = []
    for addrs in idautils.XrefsTo(func_addr):
        xref_addr_list.append(addrs.frm)


    return xref_addr_list

def print_addrs_list(addr_list):
    for i in addr_list:
        print(f"xref:{hex(i)}")

    return



def extract_dec_func_code(function_address):

    opcode_bytes = bytearray()

    # Get the function end address
    function_end = idc.get_func_attr(function_address, idc.FUNCATTR_END)

    # Iterate over the function from start to end address
    opcode_bytes = idaapi.get_bytes(function_address, function_end - function_address)
    return opcode_bytes

# Define a custom handler for the code hook
def hook_code(uc, address, size, user_data):
    # This will be triggered on every instruction
    print(f"Executing instruction at address 0x{address:X}, size {size}")

    # Optionally, you can print the current instruction from the address
    instruction = uc.mem_read(address, size)
    EAX = uc.reg_read(UC_X86_REG_EAX)
    EBX = uc.reg_read(UC_X86_REG_EBX)
    ECX = uc.reg_read(UC_X86_REG_ECX)
    EDX = uc.reg_read(UC_X86_REG_EDX)
    EBP = uc.reg_read(UC_X86_REG_EBP)
    ESP = uc.reg_read(UC_X86_REG_ESP)
    ESI = uc.reg_read(UC_X86_REG_ESI)
    EDI = uc.reg_read(UC_X86_REG_EDI)
    print(f"Instruction bytes: {instruction.hex()}")
    md = cs.Cs(cs.CS_ARCH_X86, cs.CS_MODE_32)
    for inst in md.disasm(instruction, address):
        print(f"{hex(inst.address)}, {inst.mnemonic}, {inst.op_str}")

    print(f"EAX:{hex(EAX)}, EBX:{hex(EBX)}, ECX:{hex(ECX)}, EDX:{hex(EDX)}, EDI:{hex(EDI)}, ESI:{hex(ESI)},ESP:{hex(ESP)}, EBp:{hex(EBP)}")

def emulate_decryption(dec_func_addr, xref_addr, params, shell_buff, INIT_IMGBASE, decryption_func_bytes):
    # establish memory addresses for checksum code, stack, and encrypted bytes 
    emu_address = 0x004c0000
    emu_stack_address = 0x00500000
    encrypted_shellcode = 0x00510000

    ### write decryption func and encrypted bytes in memory
    mu = Uc(UC_ARCH_X86, UC_MODE_32)
    mu.mem_map(emu_address, 30 * 1024 * 1024)
    mu.mem_write(emu_address, shell_buff) ## write the code bytes of whole shellcode

    ### set eip to our decryption routine
    mu.reg_write(UC_X86_REG_EIP, dec_func_addr)

    ### set edix and ecx register
    mu.reg_write(UC_X86_REG_ECX, params['edx'])
    mu.reg_write(UC_X86_REG_EBX, params['edx'])
    mu.reg_write(UC_X86_REG_EDX, params['ecx'])

    ### debugger hook
    #mu.hook_add(UC_HOOK_CODE, hook_code)
    
    hexdump.hexdump(mu.mem_read(dec_func_addr, len(decryption_func_bytes)))

    ### place the parameter and setup the stack
    mu.reg_write(UC_X86_REG_ESP, emu_stack_address)

    ### setup the parameter
    mu.mem_write(emu_stack_address + 4, struct.pack('<I', params['edx']))
    mu.mem_write(emu_stack_address + 8, struct.pack('<I', params['ecx']))

    start_addr = emu_address + (dec_func_addr - 0x4c0000)
    end_addr = start_addr + len(decryption_func_bytes) - 5
    print(f"start: {hex(start_addr)}, end: {hex(end_addr)}")
    try:
        mu.emu_start(start_addr, end_addr )
    except UcError as e:
        print(f"Error: {e}")
        print(f"at: {hex(mu.reg_read(UC_X86_REG_EIP))}")

    decrypted_str_addr = mu.reg_read(UC_X86_REG_EDI)
    decrypted_str_len = mu.reg_read(UC_X86_REG_ESI)
    decrypted_str = mu.mem_read(decrypted_str_addr, decrypted_str_len)
    print(f"[PROFILER]: xref_addr:{hex(xref_addr)}, ECX:{hex(params['ecx'])}, EDX:{hex(params['edx'])} decrypted_str: {decrypted_str.decode('utf-8', errors='ignore')}")
    
    return

def main():
    """
    4C63AE BA FC 74 4C 00                          mov     edx, 4C74FCh --> encrypted string
    seg000:004C63B3 B9 D4 7B 4C 00                 mov     ecx, 4C7BD4h --> decrypted function
    seg000:004C63B8 E8 59 A7 FF FF                 call    mwDynamicApiResolver
    """
    ea = idc.get_screen_ea()
    enum_func = {}
    xref_addr_list = []
    params = {}
    target_func_name_list = ["mwDynamicApiResolver"]
    INIT_IMGBASE = 0x4c0000

    ### read the shellcode file
    shellcode_file_path = "stage2.bin"
    with open(shellcode_file_path, "rb") as f:
        shell_buff = f.read()

    ### get all available functions in the shellcode
    enum_func = enumerate_functions()


    dec_func_name = "mwApiNameDecryption"
    dec_func_addr = enum_func[dec_func_name]
    
    dec_func_bytes = bytearray()

    ### decryption function byte array
    dec_func_bytes = extract_dec_func_code(dec_func_addr)

    hexdump.hexdump(dec_func_bytes)

    ### check if target function exist
    for func_name in target_func_name_list:
        
        if is_func_name_exist(enum_func, func_name):

            print(f"{func_name} --> FOUND!")

            targeted_func_addr = enum_func[func_name]

            ### find the xref
            xref_addr_list = enumerate_xref(targeted_func_addr)

            #print_addrs_list(xref_addr_list)

            for xref_addr in xref_addr_list:

                ### get the parameter of the targeted function
                params = get_function_arguments(xref_addr)
                print(f"xref_addr:{hex(xref_addr)}, params:{params}")

                ### now lets emulate the decryption function


                

                emulate_decryption(dec_func_addr, xref_addr, params, shell_buff, INIT_IMGBASE, dec_func_bytes)

                
                
            

        else:

            print(f"{func_name} --> NOT_FOUND!")
    
    
    
    
        
        
        

            
    

    
    

    return



if __name__ == "__main__":
    main()
import hexdump
import os
import sys
import idc
import idaapi
import idautils
import ida_hexrays
from unicorn import *
from unicorn.x86_const import *
import struct
import capstone as cs

def get_function_arguments(func_addr):

    """
    locate ECX and EDX opcode
    ECX = param1
    EDX = param2

    seg000:004C2CDC BA 8C 76 4C 00                          mov     edx, 4C768Ch
    seg000:004C2CE1 B9 B0 7B 4C 00                          mov     ecx, 4C7BB0h
    seg000:004C2CE6 E8 2B DE FF FF                          call    mwDynamicApiResolver
    """

    ## lets readd mnemonics 10 lines up
    MAX_SEARCH = 10



    addrs_ptr = func_addr
    params = {}
    for i in range(0, MAX_SEARCH):
        addrs_ptr = idc.prev_head(addrs_ptr)
        mnem = idc.print_insn_mnem(addrs_ptr)
        if mnem == "mov":
            mnem_addr = addrs_ptr
            op_type1 = idc.get_operand_type(addrs_ptr, 0)
            op_type2 = idc.get_operand_type(addrs_ptr, 1)            
            reg_name = idc.print_operand(addrs_ptr, 0)
            
            
            if op_type1 == o_reg and op_type2 == o_imm and (reg_name == "edx" or reg_name == "ecx"):
                op1 = idc.get_operand_value(addrs_ptr,0)
                op2 = idc.get_operand_value(addrs_ptr,1)
                print(hex(func_addr), op1, hex(op2), reg_name)
                params[reg_name] = op2              

    return params

def enumerate_functions():
    func_dict = {}

    # iterate on the functions and exclude some func type
    for func_addr in idautils.Functions():

        func_flag = idc.get_func_flags(func_addr)

        # filter out some normal function
        if (func_flag & FUNC_LIB) or (func_flag & FUNC_THUNK):
            continue
        else:
            # check if function exist on the idb
            func_name = idc.get_func_name(func_addr)
            #print(f"{hex(func_addr)}: {func_name}")
            func_dict[func_name] = func_addr


    return func_dict

def is_func_name_exist(enum_func, func_name):

    if func_name in enum_func:
        return True
    else:
        return False

def enumerate_xref(func_addr):
    xref_addr_list = []
    for addrs in idautils.XrefsTo(func_addr):
        xref_addr_list.append(addrs.frm)


    return xref_addr_list

def print_addrs_list(addr_list):
    for i in addr_list:
        print(f"xref:{hex(i)}")

    return



def extract_dec_func_code(function_address):

    opcode_bytes = bytearray()

    # Get the function end address
    function_end = idc.get_func_attr(function_address, idc.FUNCATTR_END)

    # Iterate over the function from start to end address
    opcode_bytes = idaapi.get_bytes(function_address, function_end - function_address)
    return opcode_bytes

# Define a custom handler for the code hook
def hook_code(uc, address, size, user_data):
    # This will be triggered on every instruction
    print(f"Executing instruction at address 0x{address:X}, size {size}")

    # Optionally, you can print the current instruction from the address
    instruction = uc.mem_read(address, size)
    EAX = uc.reg_read(UC_X86_REG_EAX)
    EBX = uc.reg_read(UC_X86_REG_EBX)
    ECX = uc.reg_read(UC_X86_REG_ECX)
    EDX = uc.reg_read(UC_X86_REG_EDX)
    EBP = uc.reg_read(UC_X86_REG_EBP)
    ESP = uc.reg_read(UC_X86_REG_ESP)
    ESI = uc.reg_read(UC_X86_REG_ESI)
    EDI = uc.reg_read(UC_X86_REG_EDI)
    print(f"Instruction bytes: {instruction.hex()}")
    md = cs.Cs(cs.CS_ARCH_X86, cs.CS_MODE_32)
    for inst in md.disasm(instruction, address):
        print(f"{hex(inst.address)}, {inst.mnemonic}, {inst.op_str}")

    print(f"EAX:{hex(EAX)}, EBX:{hex(EBX)}, ECX:{hex(ECX)}, EDX:{hex(EDX)}, EDI:{hex(EDI)}, ESI:{hex(ESI)},ESP:{hex(ESP)}, EBp:{hex(EBP)}")

def emulate_decryption(dec_func_addr, xref_addr, params, shell_buff, INIT_IMGBASE, decryption_func_bytes):
    # establish memory addresses for checksum code, stack, and encrypted bytes 
    emu_address = 0x004c0000
    emu_stack_address = 0x00500000
    encrypted_shellcode = 0x00510000

    ### write decryption func and encrypted bytes in memory
    mu = Uc(UC_ARCH_X86, UC_MODE_32)
    mu.mem_map(emu_address, 30 * 1024 * 1024)
    mu.mem_write(emu_address, shell_buff) ## write the code bytes of whole shellcode

    ### set eip to our decryption routine
    mu.reg_write(UC_X86_REG_EIP, dec_func_addr)

    ### set edix and ecx register
    mu.reg_write(UC_X86_REG_ECX, params['edx'])
    mu.reg_write(UC_X86_REG_EBX, params['edx'])
    mu.reg_write(UC_X86_REG_EDX, params['ecx'])

    ### debugger hook
    #mu.hook_add(UC_HOOK_CODE, hook_code)
    
    hexdump.hexdump(mu.mem_read(dec_func_addr, len(decryption_func_bytes)))

    ### place the parameter and setup the stack
    mu.reg_write(UC_X86_REG_ESP, emu_stack_address)

    ### setup the parameter
    mu.mem_write(emu_stack_address + 4, struct.pack('<I', params['edx']))
    mu.mem_write(emu_stack_address + 8, struct.pack('<I', params['ecx']))

    start_addr = emu_address + (dec_func_addr - 0x4c0000)
    end_addr = start_addr + len(decryption_func_bytes) - 5
    print(f"start: {hex(start_addr)}, end: {hex(end_addr)}")
    try:
        mu.emu_start(start_addr, end_addr )
    except UcError as e:
        print(f"Error: {e}")
        print(f"at: {hex(mu.reg_read(UC_X86_REG_EIP))}")

    decrypted_str_addr = mu.reg_read(UC_X86_REG_EDI)
    decrypted_str_len = mu.reg_read(UC_X86_REG_ESI)
    decrypted_str = mu.mem_read(decrypted_str_addr, decrypted_str_len)
    print(f"[PROFILER]: xref_addr:{hex(xref_addr)}, ECX:{hex(params['ecx'])}, EDX:{hex(params['edx'])} decrypted_str: {decrypted_str.decode('utf-8', errors='ignore')}")
    
    return

def main():
    """
    4C63AE BA FC 74 4C 00                          mov     edx, 4C74FCh --> encrypted string
    seg000:004C63B3 B9 D4 7B 4C 00                 mov     ecx, 4C7BD4h --> decrypted function
    seg000:004C63B8 E8 59 A7 FF FF                 call    mwDynamicApiResolver
    """
    ea = idc.get_screen_ea()
    enum_func = {}
    xref_addr_list = []
    params = {}
    target_func_name_list = ["mwDynamicApiResolver"]
    INIT_IMGBASE = 0x4c0000

    ### read the shellcode file
    shellcode_file_path = "stage2.bin"
    with open(shellcode_file_path, "rb") as f:
        shell_buff = f.read()

    ### get all available functions in the shellcode
    enum_func = enumerate_functions()


    dec_func_name = "mwApiNameDecryption"
    dec_func_addr = enum_func[dec_func_name]
    
    dec_func_bytes = bytearray()

    ### decryption function byte array
    dec_func_bytes = extract_dec_func_code(dec_func_addr)

    hexdump.hexdump(dec_func_bytes)

    ### check if target function exist
    for func_name in target_func_name_list:
        
        if is_func_name_exist(enum_func, func_name):

            print(f"{func_name} --> FOUND!")

            targeted_func_addr = enum_func[func_name]

            ### find the xref
            xref_addr_list = enumerate_xref(targeted_func_addr)

            #print_addrs_list(xref_addr_list)

            for xref_addr in xref_addr_list:

                ### get the parameter of the targeted function
                params = get_function_arguments(xref_addr)
                print(f"xref_addr:{hex(xref_addr)}, params:{params}")

                ### now lets emulate the decryption function


                

                emulate_decryption(dec_func_addr, xref_addr, params, shell_buff, INIT_IMGBASE, dec_func_bytes)

                
                
            

        else:

            print(f"{func_name} --> NOT_FOUND!")
    
    
    
    
        
        
        

            
    

    
    

    return



if __name__ == "__main__":
    main()
