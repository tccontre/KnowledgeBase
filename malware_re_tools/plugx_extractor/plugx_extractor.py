__author__ = "@tccontre18 - Br3akp0int"

import os
import sys
import argparse
import struct as s
import ctypes
import hexdump

DWORD_DECRYPTION_KEY_INDEX = 6
DWORD_ENCRYPTED_DATA_SIZE_INDEX = 0xE
DWORD_DECOMPRESS_DATA_SIZE_INDEX = 0xA
ENCRYPTED_BLOB_INDEX = 0x12

"""
description: a simple python script tool to extract plugx payload and config
"""

class RC4:
    def _init_(self):
        
        return

    def write_bin(self, file_path, data):
        with open(file_path, "wb") as fw:
            for dec_b in data:
                fw.write(s.pack("B",dec_b))
        return
    
    def decrypt_data(self, enc_data, key, file_path):
        s = [0]*(256)
        j = 0
        out = []
        for i in range(0, 256):
            s[i] = i

        #########
        ##KSA

        for i in range(0,256):
            j = (j + s[i] + key[i % len(key)]) %256
            s[i] , s[j] = s[j] , s[i]

        ##PRGA Phase
        i = j = 0
        for char in enc_data:
            i = ( i + 1 ) % 256
            j = ( j + s[i] ) % 256
            s[i] , s[j] = s[j] , s[i]
            dec_byte = int(char) ^ s[(s[i] + s[j]) % 256]
            out.append(dec_byte)
            
        f_path = "layer_1_extracted_" + file_path
        self.write_bin(f_path, out)
        

def get_decryption_key(f):
    f.seek(DWORD_DECRYPTION_KEY_INDEX, 0)
    dword_decryption_key = s.unpack("<L", f.read(4))[0]
    print("\n[+] decryption key: {}".format(hex(dword_decryption_key)))
    return dword_decryption_key

def get_decompress_data_size(f):
    f.seek(DWORD_DECOMPRESS_DATA_SIZE_INDEX, 0)
    dword_decompress_size = s.unpack("<L", f.read(4))[0]
    print("\n[+] decompress_size: {}".format(hex(dword_decompress_size)))
    return dword_decompress_size

def get_encrypted_data_size(f):
    f.seek(DWORD_ENCRYPTED_DATA_SIZE_INDEX, 0)
    dword_encrypted_size = s.unpack("<L", f.read(4))[0]
    print("\n[+] encrypted_size: {}".format(hex(dword_encrypted_size)))
    return dword_encrypted_size


def decompress_payload(f_path, dword_decompress_size, dword_encrypted_size):
    # Load ntdll.dll
    ntdll = ctypes.WinDLL('ntdll.dll')

    # Define the RtlDecompressBuffer function prototype
    RtlDecompressBuffer = ntdll.RtlDecompressBuffer
    RtlDecompressBuffer.argtypes = [
        ctypes.c_ulong,  # Compression format (use 0 for standard)
        ctypes.c_void_p,  # Uncompressed buffer
        ctypes.c_ulong,  # Uncompressed buffer size
        ctypes.c_void_p,  # Compressed buffer
        ctypes.c_ulong,  # Compressed buffer size
        ctypes.POINTER(ctypes.c_ulong),  # Final uncompressed size (optional)
    ]
    
    f = open(f_path, "rb")
    
    
    compressed_data = f.read()
    f.seek(0,0)
    show_hex_dump_preview(f, "LZNT1 COMPRESSED", f_path, 400)
        
    # Define your compressed data and output buffer
    compressed_size = dword_encrypted_size
    compressed_buffer = ctypes.create_string_buffer(compressed_data)

    # Create a buffer for the uncompressed data
    uncompressed_size = dword_decompress_size
    uncompressed_buffer = ctypes.create_string_buffer(uncompressed_size)
        
    # Determine the uncompressed size (optional)
    final_size = ctypes.c_ulong()
   
    # Decompress the data into the uncompressed buffer
    result = RtlDecompressBuffer(
        2,  
        uncompressed_buffer,
        uncompressed_size,
        compressed_buffer,
        compressed_size,
        final_size
    )

    if result == 0:
        with open("extracted_plugx_payload.bin", "wb") as fw:
            fw.write(uncompressed_buffer.raw)
        with open("extracted_plugx_payload.bin", "rb") as fr:
            show_hex_dump_preview(fr, "FINAL PAYLOAD", "extracted_plugx_payload.bin", 1000)
    return 

def show_hex_dump_preview(f, string1, string2, size):
    print("\n[+] File saved to: [{}].....".format(string2))
    print("[HEXDUMP PREVIEW][{}]---------------------------------".format(string1))
    
    buff = f.read(size)
    hexdump.hexdump(buff)
    return

def decrypt_2nd_layer(file_path, f, dword_decryption_key, dword_encrypted_size, ENCRYPTED_BLOB_INDEX):
    f.seek(ENCRYPTED_BLOB_INDEX, 0)
    buff = f.read()
    dec_key = dword_decryption_key
    f_path = "layer_2_extracted_" + file_path 
    dec_byte = b'0'
    dec_array = bytearray()
    for i in range(0, len(buff)):
        dec_key += 1
        dec_byte = (buff[i] - (dec_key & 0x000000FF)) & 0x000000FF
        dec_byte = (dec_byte ^ (dec_key & 0x000000FF)) & 0x000000FF
        dec_byte = (dec_byte + (dec_key & 0x000000FF)) & 0x000000FF
        dec_array.append(dec_byte) 

    with open(f_path, "wb") as fw:
        fw.write(dec_array)
    
    return f_path

def decrypt_plugx(file_path):
    layer1_path = "layer_1_extracted_" + file_path 
    f = open(layer1_path, "rb")
    show_hex_dump_preview(f, "SHELLCODE", layer1_path, 400)
    dword_decryption_key = get_decryption_key(f)
    dword_decompress_size = get_decompress_data_size(f)
    dword_encrypted_size = get_encrypted_data_size(f)
    f_path = decrypt_2nd_layer(file_path, f, dword_decryption_key, dword_encrypted_size, ENCRYPTED_BLOB_INDEX)
    f.close()
    decompress_payload(f_path, dword_decompress_size, dword_encrypted_size)
    return

def get_config_dec_key(f):
    dword_dec_key = s.unpack("<L", f.read(4))[0]
    print("[+] config_dec_key: {}".format(hex(dword_dec_key)))
    return dword_dec_key

def main():
    RC4_KEY = [0xb1, 0x2a, 0xf1, 0x41]
    rc4 = RC4()
    parser = argparse.ArgumentParser(description = "Plugx Payload/Config Extraction Tool ~ [@tccontre18 - Br3akp0int] ~ ")
    parser.add_argument('-f', '--dat_filepath', help = "Plugx Encrypted .DAT File", required=False)
    parser.add_argument('-c', '--cfg_filepath', help = "Plugx Encrypted .CFG File", required=False)
    
    args = vars(parser.parse_args())
    file_path = args ['dat_filepath']
    cfg_path = args ['cfg_filepath']
    
    if file_path != None:
        with open(file_path, "rb") as f:
            buff = f.read()
        print("[+] Decrypting PlugX DAT File: {0}".format(file_path))    
        rc4.decrypt_data(buff, RC4_KEY, file_path)

        decrypt_plugx(file_path)
    elif cfg_path != None:
        print("[+] Decrypting PlugX CFG File: {0}".format(cfg_path))
        
        fr = open(cfg_path, "rb")
        dword_dec_key = get_config_dec_key(fr)
        fr.seek(0,0)
        buff = fr.read()
        fr.seek(0,0)
        show_hex_dump_preview(fr, "CFG", cfg_path, len(buff))
        fr.close()
        
        # Convert the DWORD to bytes
        byte_list = s.pack('<I', dword_dec_key)
        byte_list = list(byte_list)
        rc4.decrypt_data(buff, byte_list, cfg_path)
        c_path = "layer_1_extracted_" + cfg_path 
        ff = open(c_path, "rb")
        b =ff.read()
        ff.seek(0,0)
        show_hex_dump_preview(ff, "CFG EXTRACTED", c_path, len(b))
   

    return



if __name__ == "__main__":
    main()
