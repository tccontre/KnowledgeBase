import re
import struct
from dnfile import dnPE
from dnfile.mdtable import MethodDefRow
import os
import sys
import dnfile
from dnfile.enums import MetadataTables

from dncil.cil.body import CilMethodBody
from dncil.cil.error import MethodBodyFormatError
from dncil.clr.token import Token, StringToken, InvalidToken
from dncil.cil.body.reader import CilMethodBodyReaderBase

import yaml


class DnfileMethodBodyReader(CilMethodBodyReaderBase):
    def __init__(self, pe, row):
        """ """
        self.pe = pe
        self.offset = self.pe.get_offset_from_rva(row.Rva)

    def read(self, n):
        """ """
        data = self.pe.get_data(self.pe.get_rva_from_offset(self.offset), n)
        self.offset += n
        return data

    def tell(self):
        """ """
        return self.offset

    def seek(self, offset):
        """ """
        self.offset = offset
        return self.offset

    
class DnfileParse():
    DOTNET_META_TABLES_BY_INDEX = {table.value: table.name for table in MetadataTables}
    
    @staticmethod
    def read_dotnet_user_string(pe, token):
        """read user string from #US stream"""
        try:
            user_string = pe.net.user_strings.get_us(token.rid)
        except UnicodeDecodeError as e:
            return InvalidToken(token.value)

        if user_string is None:
            return InvalidToken(token.value)

        return user_string.value

    @staticmethod
    def resolve_token(pe, token):
        """ """
        if isinstance(token, StringToken):
            return DnfileParse.read_dotnet_user_string(pe, token)

        table_name = DnfileParse.DOTNET_META_TABLES_BY_INDEX.get(token.table, "")
        if not table_name:
            # table_index is not valid
            return InvalidToken(token.value)

        table = getattr(pe.net.mdtables, table_name, None)
        if table is None:
            # table index is valid but table is not present
            return InvalidToken(token.value)

        try:
            return table.rows[token.rid - 1]
        except IndexError:
            # table index is valid but row index is not valid
            return InvalidToken(token.value)

    @staticmethod
    def read_method_body(pe, row):
        """ """
        return CilMethodBody(DnfileMethodBodyReader(pe, row))

    @staticmethod
    def format_operand(pe, operand):
        """ """
        if isinstance(operand, Token):
            operand = DnfileParse.resolve_token(pe, operand)

        if isinstance(operand, str):
            return f'"{operand}"'
        elif isinstance(operand, int):
            return hex(operand)
        elif isinstance(operand, list):
            return f"[{', '.join(['({:04X})'.format(x) for x in operand])}]"
        elif isinstance(operand, dnfile.mdtable.MemberRefRow):
            if isinstance(operand.Class.row, (dnfile.mdtable.TypeRefRow,)):
                return f"{str(operand.Class.row.TypeNamespace)}.{operand.Class.row.TypeName}::{operand.Name}"
        elif isinstance(operand, dnfile.mdtable.TypeRefRow):
            return f"{str(operand.TypeNamespace)}.{operand.TypeName}"
        elif isinstance(operand, (dnfile.mdtable.FieldRow, dnfile.mdtable.MethodDefRow)):
            return f"{operand.Name}"
        elif operand is None:
            return ""

        return str(operand)

    @staticmethod
    def get_instruction_text(pe, insn):
        return "{:04X}".format(insn.offset) \
                + "    " \
                + f"{' '.join('{:02x}'.format(b) for b in insn.get_bytes()) : <20}" \
                + f"{str(insn.opcode) : <15}" \
                + DnfileParse.format_operand(pe, insn.operand)

def main():
    SAMPLE_PATH = "C:\\Users\\Public\\njrat_samples"
    yaml_buff = {}
    njrat_data_list = []
    
    for dirs, subdirs, files in os.walk(SAMPLE_PATH):
        for f in files:
            tmp_dict = {}
            tmp_dict["sha256"] = f.replace(".-1","")
            print(f)
            file_path = os.path.join(dirs, f)
            pe = dnfile.dnPE(file_path)

            print("net struct len: {}".format(len(pe.net.mdtables.tables_list)))

            for row in pe.net.mdtables.MethodDef:
                if not row.ImplFlags.miIL or any((row.Flags.mdAbstract, row.Flags.mdPinvokeImpl)):
                    # skip methods that do not have a method body
                    continue

                try:
                    body = DnfileParse.read_method_body(pe, row)
                except MethodBodyFormatError as e:
                    print(e)
                    continue

                if not body.instructions:
                    continue

                if row.Name == ".cctor":
                    ldstr_count = 0
                    for index in range(0, len(body.instructions)):
                        inst = body.instructions[index]
                        inst_ = DnfileParse.get_instruction_text(pe, inst)
                        if str(inst.opcode) == "ldstr":
                            ldstr_count +=1
                    if ldstr_count >=3:
                        #print("ldstr_count: {}".format(ldstr_count))
                        code_buf = ""
                        config_str_list = []
                        for index in range(0, len(body.instructions)):
                            inst = body.instructions[index]
                            inst_ = DnfileParse.get_instruction_text(pe, inst)
                            try:
                                code_buf += inst_
                                code_buf += "\n"
                                #print(inst_)

                                if str(inst.opcode) == "ldstr":
                                    #print(DnfileParse.resolve_token(pe, inst.operand))
                                    config_str_list.append(str(DnfileParse.resolve_token(pe, inst.operand)))
                                
                            
                            except Exception as e:
                                print(e)
                                continue

                        tmp_dict["config_raw_code_block"] = code_buf
                        tmp_dict["config_str"] = config_str_list
                        
                        njrat_data_list.append(tmp_dict)

        yaml_buff["njrat_extract_config"]=njrat_data_list

        with open('njrat_config_info.yaml', 'w') as file:
            documents = yaml.dump(yaml_buff, file)
                    
                    
            
            

        

    return




if __name__ == "__main__":
    main()


