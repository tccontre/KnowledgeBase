##################################################
### Script Name: pixdig.ps1
### Description: PowerShell script to extract payloads from BMP and PNG files using steganography
### Author: Teoderick Contreras, @tccontre18 - Br3akp0int
### Date: 2025-07-28   
### Version: 1 
### Usage: .\pixdig.ps1 -Path "C:\path\to\your\file_or_directory"

param (
    [Parameter(Mandatory = $true)]
    [string]$Path
)

##########################################
### Function Declaration
##########################################

function Process-Path {
    param (
         [Parameter(Mandatory = $true)]
         [string]$Path
    )
	Show-Banner
	
    Warning-WriteHost "[PROCESSING] $Path"
    ### check if path exist
    if (Test-Path $Path){

        ### check if it is folder path
        if (Test-Path $Path -PathType Container) {
            Get-ChildItem -Path $Path -File | ForEach-Object {
                Process-File $_.FullName
            }        

        }
        ### if not container it is a file path
        else {
            Process-File $Path
        }
    }

}

function Show-Banner {
    Clear-Host
    $banner = @"

    ___     _              ___      _      __ _  
   | _ \   (_)    __ __   |   \    (_)    / _` | 
   |  _/   | |    \ \ /   | |) |   | |    \__, | 
  _|_|_   _|_|_   /_\_\   |___/   _|_|_   |___/  
 | """ |_|"""""|_|"""""|_|"""""|_|"""""|_|"""""| 
 "`-0-0-'"`-0-0-'"`-0-0-'"`-0-0-'"`-0-0-'"`-0-0-' 

by: @tccontre18 - Br3akp0int
--------------------------------------------------------------------------
"@
    Write-Host $banner -ForegroundColor Yellow
}




function Info-WriteHost {
    param (
        [Parameter(Mandatory = $true)]
        [string]$Message
    )
    Write-Host "[+] Status: $Message" -ForegroundColor Green
}

function Warning-WriteHost {
    param (
        [Parameter(Mandatory = $true)]
        [string]$Message
    )
    Write-Host "[+] Status: $Message" -ForegroundColor Yellow
}


function Error-WriteHost {
    param (
        [Parameter(Mandatory = $true)]
        [string]$Message
    )
    Write-Host "[+] Status: $Message" -ForegroundColor Red
}



function Notes-WriteHost {
    param (
        [Parameter(Mandatory = $true)]
        [string]$Message
    )
    Write-Host "[+] Status: $Message" -ForegroundColor cyan
}

function Create-OutputDir {
    param (
        [Parameter(Mandatory = $true)]
        [string]$FilePath
    )

    $baseName = [System.IO.Path]::GetFileNameWithoutExtension($filePath)
    $curDir = Get-Location
    $saveDirPath = Join-Path -Path $curDir -ChildPath $baseName

    # Create the folder if it doesn't exist
    if (-not (Test-Path -Path $saveDirPath)) {
        New-Item -Path $saveDirPath -ItemType Directory | Out-Null
    }

    Info-WriteHost "[CREATED]: output folder: $baseName"
    
    return $saveDirPath
}

function Decrypt-Bmp-Payload{
    param (
        [Parameter(Mandatory = $true)]
        [string]$bmpFilePath  # This parameter will receive the byte array
    )
    
if (!(Test-Path $bmpFilePath)) {
    Error-WriteHost "[ERROR]: File does not exist at path: $bmpFilePath"
    return
    }

    $extractedBytes = [System.IO.File]::ReadAllBytes($bmpFilePath)

    # Create Bitmap from MemoryStream
    $memoryStream = [System.IO.MemoryStream]::new($extractedBytes)

    $extractedBitmap = [System.Drawing.Bitmap]::new($memoryStream)

    
    HexDump $extractedBytes $bmpFilePath

    # Step 3: Prepare the list to store the processed bytes
    $list = New-Object System.Collections.Generic.List[byte]

    # Some initial numbers for the algorithm (same as the C# code)
    $num = 128512
    $num2 = 3735928559

    # Initialize the loop variables
    $num3 = 0

    # Step 4: Process the image (mimic the loop behavior from C# code)
    while ($num3 -lt $extractedBitmap.Width -and $list.Count -lt $num) {
        # Simulate the number transformation (rotating num2)
        $num2 = (($num2 -shl 13) -bor ($num2 -shr 19))

        # Cupcake method equivalent: You would define your own logic for image manipulation here.
        # (Placeholder logic for Cupcake function in PowerShell; you can define custom processing)
        Parse-Pixel -src $extractedBitmap -bytes ([ref]$list) -x $num3 -length $num


        # Increment the loop counter
        $num3++
    }

    # Step 5: Convert the list to a byte array
    $byteArray = $list.ToArray()

    Warning-WriteHost "[EXTRACTED] BMP Stegonography Payload <= $bmpFilePath"

    $bmpExtractedPayloadFilePath = $bmpFilePath + "_extracted_payload.bin"

    HexDump $byteArray $bmpExtractedPayloadFilePath

    # Step 6: Write the byte array to a file (same as File.WriteAllBytes in C#)
    [System.IO.File]::WriteAllBytes($bmpExtractedPayloadFilePath, $byteArray)

    # Display success message
    Info-WriteHost "[EXTRACTED] saved successfully."
}


function DecodePixel {
    param (
        [ref]$bytes,

        [System.Drawing.Color]$pixel,
        [int]$remaining
    )
    #Info-WriteHost "pixel: $pixel"
    #Info-WriteHost "remaining: $remaining"
    # $num2 = ($pixel.R -shl 16) -bor ($pixel.G -shl 8) -bor $pixel.B
    $num2 = ([int]$pixel.R -shl 16) -bor ([int]$pixel.G -shl 8) -bor ([int]$pixel.B)
    #$num2Hex = "0x{0:X}" -f $num2
    #Info-WriteHost "num2: $num2Hex"
    $byteArray = [byte[]]@(
        [byte]($num2 -shr 16 -band 255),
        [byte]($num2 -shr 8 -band 255),
        [byte]($num2 -band 255)
    )
    
    # Instead of AddRange, manually add each byte
    foreach ($byte in $byteArray) {
        #Info-WriteHost "$byte"
        $bytes.Value.Add($byte)  # This works because $bytes.Value is a List[byte]
    }

    

    return 
}

function Parse-Pixel {
    param (
        [System.Drawing.Bitmap]$src,
        [ref]$bytes,
        [int]$x,
        [int]$length
    )
    
    $num = 0
    while ($num -lt $src.Height -and $bytes.Value.Count -lt $length) {
        $pixel = $src.GetPixel($x, $num)
        
        $remaining = $length - $bytes.Value.Count

        #Info-WriteHost "pixel: $pixel"
        #Info-WriteHost "remaining: $remaining"
        #Info-WriteHost "length: $length"
        #Info-WriteHost "bytecount: $bytes.Value.Count"
        DecodePixel -bytes $bytes -pixel $pixel -remaining $remaining
        $num++
    }
    
    return 
}


function HexDump {
    param (
        [Parameter(Mandatory = $true)]
        [byte[]]$byteArray,
        [string]$msg 
    )

    Notes-WriteHost "=================================================================="
    Notes-WriteHost "[MINI-HEXDUMP]: $msg"


    $byteArray | Format-Hex | select -first 20

    Notes-WriteHost "=================================================================="

}

function Decrypt-Png-Payload {

    param (
        [Parameter(Mandatory = $true)]
        [string]$pngFilePath  # This parameter will receive the byte array
    )


    $extractedBytes = [System.IO.File]::ReadAllBytes($pngFilePath)

    # Create Bitmap from MemoryStream
    $memoryStream = [System.IO.MemoryStream]::new($extractedBytes)

    $extractedBitmap = [System.Drawing.Bitmap]::new($memoryStream)

    HexDump $extractedBytes $pngFilePath

    $width = $extractedBitmap.Width
    $height = $extractedBitmap.Height

    $paddingSize = 0x96

    $newWidth = $width - $paddingSize
    $newHeight = $height - $paddingSize

    $arraySize = $newWidth * $newHeight * 4
    $encPayloadBuff = New-Object byte[] $arraySize
    $tempPixelByteBuff = New-Object byte[] 4

    $buffPtr = 0
    $newBitmap = New-Object System.Drawing.Bitmap($newWidth, $newHeight)

    for ($y = 0; $y -lt $newHeight; $y++) {
        for ($x = 0; $x -lt $newWidth; $x++) {
            $pixel = $extractedBitmap.GetPixel($x, $y)
            $newBitmap.SetPixel($x, $y, $pixel)
        }
    }

    for ($w = 0; $w -lt $newWidth; $w++) {
        for ($h = 0; $h -lt $newHeight; $h++) {
            $newPixel = $newBitmap.GetPixel($w, $h)
            $tempPixelByteBuff = [System.BitConverter]::GetBytes($newPixel.ToArgb())
            [Array]::Copy($tempPixelByteBuff, 0, $encPayloadBuff, $buffPtr, 4)
            $buffPtr += 4
        }
    }
    Info-WriteHost "[INFO] encrypted png payload: $pngFilePath"

    Hexdump $encPayloadBuff $pngFilePath

    $actualPayloadSize = New-Object byte[] 4
    [Array]::Copy($encPayloadBuff, 0, $actualPayloadSize, 0, 4)

    $iActualPayloadSize = [System.BitConverter]::ToInt32($actualPayloadSize, 0)
    Info-WriteHost ("[INFO] actual Payload size: 0x" + $iActualPayloadSize.ToString("X8"))

    $initDecryptionIndexByte = $encPayloadBuff[$iActualPayloadSize + $actualPayloadSize.Length - 1]
    $decryptionIndexByte = $initDecryptionIndexByte -bxor 0x70

    Info-WriteHost ("[INFO] decryption Index byte: 0x" + $decryptionIndexByte.ToString("X2"))

    $decPayloadBuff = New-Object byte[] $iActualPayloadSize
    #$decryptionKey = @(0x00, 0x64, 0x00, 0x78, 0x00, 0x68)

    ### retrieve the 3 byte decryption key
    $dummyBytes = @(0x4d, 0x5a, 0x90)
    $decryptionKey = @(0x00, 0x00, 0x00)
    for ($k = 0; $k -lt 3; $k++) {
        $decryptionKey[$k] = $encPayloadBuff[$k + 4] -bxor $decryptionIndexByte -bxor $dummyBytes[$k % 3]
    }

    Info-WriteHost "[INFO] decryption key array: $decryptionKey"


    for ($e = 0; $e -lt $iActualPayloadSize; $e++) {
        $decPayloadBuff[$e] = $encPayloadBuff[$e + 4] -bxor $decryptionIndexByte -bxor $decryptionKey[$e % 3]
    }

    Warning-WriteHost "[EXTRACTED] PNG Stegonography Payload <= $pngFilePath"

    $pngExtractedPayloadFilePath = $pngFilePath + "_extracted_payload.bin"

    [System.IO.File]::WriteAllBytes($pngExtractedPayloadFilePath, $decPayloadBuff)

    Hexdump $decPayloadBuff $pngFilePath

    # Display success message
    Info-WriteHost "[EXTRACTED] saved successfully."
}

function Process-File {
    param (
        [Parameter(Mandatory = $true)]
        [string]$FilePath
    )

    Warning-WriteHost "[PROCESSING]: $FilePath"
    
    $saveDirPath = Create-OutputDir $FilePath

    #### get .net resource properties
    try {
    $assembly = [System.Reflection.Assembly]::LoadFile($FilePath)
    }
    catch {
        Error-WriteHost "[ERROR] failed to load the file"
        Error-WriteHost "[ERROR] $($_.Exception.Message)"
        #Error-WriteHost "[ERROR] Stack Trace: $($_.Exception.StackTrace)"
        return
    }

    $resourceNames = $assembly.GetManifestResourceNames()

    ### iterate in all resource properties found in the file inputted
	
    foreach($rsrcEntry in $resourceNames) {
        if ($rsrcEntry.contains("resource")) {
            Info-WriteHost "[SCANNED] Steganography2025 Pattern Found: $rsrcEntry" 
            Warning-WriteHost "[PARSING] raw resource properties: $rsrcEntry"

            $stream = $assembly.GetManifestResourceStream($rsrcEntry)
            $resourceReader = New-Object System.Resources.ResourceReader($stream)

            foreach ($entry in $resourceReader) {

                #### parsing the dictionary output of resourceReader
                $entryKey = $entry.Key
                $entryValue = $entry.Value

                ###check if the resource is a bitmap object type
                if ($entryValue -is [System.Drawing.Bitmap]) {

                    

                    $outputFilePath = Join-Path -Path $saveDirPath -ChildPath "$entryKey"
                
                    ### write the image to the file system
                    $memoryStream = New-Object System.IO.MemoryStream
                    $formatter = New-Object System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
                    $formatter.Serialize($memoryStream, $entryValue)
                    $rawBytes = $memoryStream.ToArray()
                    $memoryStream.Close()

                    ### check if it is BMP or PNG
                    HexDump $rawBytes $entryKey

                    $isPng = $rawBytes[0xa1] -eq 0x89 -and  $rawBytes[0xa2] -eq 0x50 -and $rawBytes[0xa3] -eq 0x4e -and $rawBytes[0xa4] -eq 0x47
                    $isBmp = $rawBytes[0xa1] -eq 0x42 -and  $rawBytes[0xa2] -eq 0x4d 

                    if ($isPng) {
                        $memoryStream = New-Object System.IO.MemoryStream
                        $entryValue.Save($memoryStream, [System.Drawing.Imaging.ImageFormat]::Png)  # Save as raw BMP data (no conversion)
                        $rawPngBytes = $memoryStream.ToArray()
                        $memoryStream.Close()
                    
                        # Write raw bytes to file
                        Notes-WriteHost "type png: $isPng --> saving PNG $entryKey"
                        $outputFilePath = $outputFilePath + ".png"
                        [System.IO.File]::WriteAllBytes($outputFilePath, $rawPngBytes)

                        ### extract the payload from this bmp file
                        Warning-WriteHost "[DECRYPTING] PNG Stegonography: $entryKey"
                        Decrypt-Png-Payload $outputFilePath
                        
                    }
                    if ($isBmp) {
                        $memoryStream = New-Object System.IO.MemoryStream
                        $entryValue.Save($memoryStream, [System.Drawing.Imaging.ImageFormat]::Bmp)  # Save as raw BMP data (no conversion)
                        $rawBmpBytes = $memoryStream.ToArray()
                        $memoryStream.Close()
                    
                        # Write raw bytes to file
                        Notes-WriteHost "type bmp: $isbmp --> saving BMP $entryKey"
                        $outputFilePath = $outputFilePath + ".bmp"
                        [System.IO.File]::WriteAllBytes($outputFilePath, $rawBmpBytes)

                        ### extract the payload from this bmp file
                        Warning-WriteHost "[DECRYPTING] BMP Stegonography: $entryKey"
                        Decrypt-Bmp-Payload $outputFilePath




                        
                    }
                

                 }
            

            }
        }

    }
 
}




Process-Path -Path $Path
